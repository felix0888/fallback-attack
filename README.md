# Fallback Attack
Smart Contract Security Practice | Lv1 Fallback Attack
```
!!! DON'T TRY ON MAINNET !!!
```

## SUMMARY
Look carefully at the contract's code below. You find a security risk on the contract and expose it.

#### You will beat this level if

- you claim ownership of the contract
- you reduce its balance to 0

#### Things that might help
- How to send ether when interacting with an ABI
- How to send ether outside of the ABI
- Difference between send - call - transfer
- Converting to and from wei/ether units (see help() command)
- Fallback methods

## SMART CONTRACT CODE
```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.5 <0.9.0;

contract Fallback {
  mapping(address => uint256) public contributions;
  address payable public owner;

  constructor() {
    owner = payable(msg.sender);
    contributions[msg.sender] = 1000 * (1 ether);
  }

  modifier onlyOwner {
    require(msg.sender == owner, "caller is not the owner");
    _;
  }

  event NewOwner(address _newOwner);

  function contribute() public payable {
    require(msg.value < 0.001 ether);
    contributions[msg.sender] += msg.value;
    if (contributions[msg.sender] > contributions[owner]) {
      owner = payable(msg.sender);
      emit NewOwner(msg.sender);
    }
  }

  function getContribution() public view returns (uint256) {
    return contributions[msg.sender];
  }

  function withdraw() public onlyOwner {
    owner.transfer(address(this).balance);
  }

  fallback() external payable {
    require(msg.value > 0 && contributions[msg.sender] > 0);
    owner = payable(msg.sender);
    emit NewOwner(msg.sender);
  }
}
```

## HOW TO EXPOSE THE SECURITY RISK?
#### Fallback method changes the owner of the contract, so how can we make it happen?
You could find the code line that uses `call` function instead of `transfer` or `send` in order to send ether to the target contract in `Hacker.sol`.
In many documents, `call` is dangerous, and needs care about using it.
And I do recommend not to use it for your real smart contract.

One of the important differences between `call` and `transfer` or `send`, is that when using `call`, you can set the amount of gas that will be available in the transaction generated by `call` call.

The `call` in `Hacker` contract will call `fallback` function in `Fallback` contract.

Look at that `fallback` function, and try to predict how many gas it would need?
Here are some Ethereum specifications that help you to calculate it.

> To occupy a 256 Bit slot of Storage costs 20,000 gas. Changing a value of an already occupied slot costs 5,000 gas.

In the `fallback` function, it replaces the `owner` with the new one, and the `owner` is a state variable that stores on Storage. Then you can easily get the amount of gas required for the `fallback` function as roughly more than 25,000 gas.

#### Why to use call?
But `trasfer` and `send` functions are limited with 2300 gas stipend and not adjustable. So, if you attack with `transfer` or `send`, you will get "Out of Gas" exception, and in many cases, Remix, truffle and etc, they don't give the exact error description.

With `call` you can adjust the amount gas used in the called contract, and the sufficient amount of gas will allow the target contract to replace the owner, ultimately you will get success on the attack.

## DEPLOY & TEST
#### Installation
```
npm install
npx hardhat node
```

#### Deployment
```
npx hardhat run --network [NETWORK-NAME] scripts/deploy.js
```

#### Test
```
npx hardhat test
```

You can test fallback on the local hardhat node as well.
